\documentclass[utf8]{article}

\usepackage[utf8]{inputenc}

\usepackage[parfill]{parskip}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listingsutf8}
\usepackage{underscore}

\usepackage{fullpage}


\title{Rapport du projet 2 : ULBMP}
\author{LI Min-Tchun}
\date{12/05/2024}

\begin{document}
\maketitle
\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{logo.png}
\label{fig:logo}
\end{figure}

\newpage
\tableofcontents
\newpage
\section{Introduction}
Pour le deuxième projet du cours INFO-F-106, nous avons dû implémenter un compresseur d'image appelé ULBMP, basé sur le format BMP, développé par Microsoft dans les années 80.

Afin de pouvoir venir à bout de ce projet, il est demandé d'importer le module \textit{Pyside6} afin de pouvoir créer un interface grahpique pour l'utilisateur. Il est donc important de lire la documentation de ce module afin de pouvoir l'utiliser correctement.

De plus, il est fondamental de maitriser la manipulation de fichier, de bits (notamment le shifting et le masking), ainsi que la compréhension de la représen-tation binaire et hexadécimal.

En effet, comme nous devons utiliser des pixels, il est important de comprendre que ces derniers sont composées de 3 valeurs : Rouge, Vert, Bleu (RVB ou RGB en anglais). Chacune de ces valeurs est codée sur 8 bits, ce qui signifie que chaque valeur peut prendre $2^8 = 256$ valeurs différentes.


Il était donc utile d'utiliser le programme \textbf{hexdump}, à exécuter dans le terminal afin de pouvoir visualiser les données hexadécimale.

Cependant, une question se pose : comment pouvons-nous représenter une image en format numérique ou bien comment pouvons-nous compresser une image ? Afin de résoudre ce problème, on va procéder comme suit, nous allons créer une classe \textit{Decoder} et \textit{Encoder}. 

Le premier permettra, à partir d'un chemain d'accès du fichier, de lire chaque bytes et de retourner une \textit{image} (nous définierons plus tard plus précisemment ce que c'est).  

Le deuxième permettra, à partir d'une \textit{image}, d'écrire dans un fichier les bytes correspondants aux valeurs RGB de chaque pixel.

Il est important de notifier qu'il y a plusieurs version du compresseur d'image. Cela signifie que le header (ce qui se trouve à chaque début de fichier pour reconnaitre le format du fichier) doit être adapté à chaque version.


\section{Méthodes}
Comme cité dans l'introduction, nous allons devoir implémenter deux classes : \textit{Decoder} et \textit{Encoder}. Mais avant ça, il va falloir définir les classes \textit{Pixel} et \textit{Image}. 
\subsection{Pixel et Image}
La classe \textit{Pixel} possède les attributs suivants : r, g, b (ces derniers correspondent aux valeurs RGB d'un pixel). 
Le constructeur \textit{Image} prend en paramètre la hauteur, la largeur de l'image, ainsi qu'une liste de taille $hauteur \times largeur$ comprenant des instances de la classe Pixel.
Certaines fonctions spécifiques à la construction de classes doivent être créé pour faciliter la manipulation des pixels et des images. Par exemple, la fonction \texttt{__getitem__} de la classe \textit{Image} permet de récupérer un pixel à partir de ses coordonnées (x, y).

\begin{lstlisting}[language=Python]
def __getitem__(self, pos: tuple[int, int]):
    x = pos[0]
    y = pos[1]
    if not (x <= self.w and y <= self.h):
        raise IndexError("Not enough pixels.")
    return self.img[y * self.w + x]

\end{lstlisting}

Ou bien la fonction \texttt{__setitem__} qui permet de modifier un pixel à partir de ses coordonnées (x, y).
\begin{lstlisting}[language=Python]
 def __setitem__(self, pos: tuple[int, int], pix):
    x = pos[0]
    y = pos[1]
    if x < self.w or y < self.h:
        self.img[x + y * self.w] = pix
    else:
        raise IndexError("Invalid position.")

\end{lstlisting}

Par ailleurs, rappelons nous que chaque couleur du pixel est encodée sur 8 bits, ce qui signifie qu'il est impossible d'avoir des valeurs négatives ou supérieures à 255. De plus, une image ne peut pas posséder une quantité de pixel supérieure à la dimension de l'image. Par exemple, si une image a une hauteur de 5 et une largeur de 3, il est impossible d'accéder au pixel d'indice (6, 2) car il n'existe pas.

Voilà pourquoi les constructeurs des classes \textit{Pixel} et \textit{Image} sont définis comme suit :

Pour la classe Pixel : 
\begin{lstlisting}[language=Python]
def __init__(self, r, g, b):
    self.red = r
    self.green = g
    self.blue = b
    if self.red < 0 or self.green < 0 or self.blue < 0:
        raise ValueError("RGB values must be positive.")
    self.pixel = (self.red, self.green, self.blue)
\end{lstlisting}

Pour la classe Image : 

\begin{lstlisting}[language=Python]
 def __init__(self, width: int, height: int, pixels):
    self.w = width
    self.h = height
    self.img = pixels
    if self.w * self.h != len(self.img):
      raise ValueError("Quantity of pixels doesn't match the image's dimension.")
    for i in pixels:
        if not isinstance(i, Pixel):
		  raise ValueError("List's elements aren't Pixel instances.")
\end{lstlisting}

\subsection{Encoder}
La classe \textit{Encoder} possède les attributs suivants : une instance de la classe \textit{Image}, la version du compresseur que nous  voulons utiliser (mis par défaut à 1), et **kwargs. Ce dernier permet de passer des arguments optionnels, tels que la profondeur et une une valeur booléene déterminant l'utilisation de l'encodage RLE (passer à True si nous souhaitons utiliser la encodage RLE, False sinon).

La première version de l'\textit{Encoder} permettait seulement d'analyser les bits un à un et ensuite l'écrire dans un fichier. Cependant, cette méthode n'est pas optimale car elle ne permet pas de compresser l'image. C'est pourquoi, il est important de créer une deuxième version de l'\textit{Encoder} qui permettera  de compresser l'image.

Nous avons cité précedemment la notion de encodage RLE. Ce dernier consiste à remplacer une suite de bits identiques par un seul bit qui correspondra au nombre de répétitions du bit. Dans notre cas, si nous avons une suite de 10 pixels identiques, nous utiliserons un bytecorrespondra à 10. Ainsi, au lieu d'encoder les pixels sur 3 bytes, nous les encoderons sur 4 bytes dont le premier représentera le nombre de répétitions des bits suivants.

Quant à la profondeur, elle correspond au nombre de bits utilisés pour encoder chaque couleur d'un pixel. Par exemple, si la profondeur est de 4, cela signifie que chaque couleur d'un pixel est encodée sur 4 bits. Cette méthode d'encodage sera utiliser pour la version 3.0 du compresseur. 

Nous avons également dû implémenter une quatrième  version de l'\textit{Encoder}. L'idée est de regrouper les pixels en fonction de leur différence de couleur. Si par exemple, soit deux pixels : $P_1 = (R_1, G_1, B_1)$ et $P_2 = (R_2, G_2, B_2)$, la différence de couleur entre ces deux pixels est définie comme suit : 

\begin{align*}
		\Delta_R = R_2 - R_1 \\
		\Delta_G = G_2 - G_1 \\
		\Delta_B =  B_2 - B_1 \\
\end{align*}

Ainsi, en fonction des intervalles de valeurs de $\Delta_R$, $\Delta_G$ et $\Delta_B$, nous allons regrouper les pixels en fonction de leur différence de couleur. Plus la différence sera grande, plus on aura besoin de byte pour encoder les pixels. En effet, si la différence n'est pas grande (c'est-à-dire entre -2 et 1), la couleur des pixels sont assez proche pour qu'on ne voit pas la différence à l'oeil nu. Ainsi, on peut se permettre de les encoder sur moins de bytes.

Il est important de noter qu'il va falloir décaler les valeurs de différences car il est possible que ces dernières soient négatives. De plus, le calcul de différence se fera toujours à partir du pixel actif et le pixel précédent.
% Si trop de page flm, mais sinon peut-être préciser les différents types de bloc.

Comme il fallait implémenter plusieurs versions de l'\textit{Encoder}, il était important de créer une méthode \texttt{get_header} qui permet de retourner une suite de bytes correspondant au header contenant la constante ULBMP (c'est ce qui permet d'identifier nous sommes en train d'analyser le format correct du fichier), la hauteur, la largeur, la taille du header (mis par défaut à 12 car elle varie seulement pour la version 3) et la version. En fonction de la valeur du paramètre \textit{version}, nous ajouterons des informations supplémentaires dont la profondeur et l'encodage RLE. À ceux-là s'ajoute lapalette, qui 
\subsection{Decoder}
La classe \textit{Decoder} se repose seulemetn sur la méthode statique \texttt{load_from} qui prend en paramètre le chemin d'accès du fichier à lire. Cette méthode permet de lire les bytes du fichier et de les convertir en une instance de la classe \textit{Image}.

\section{ULBMP 2.0}
Ceci est le chapitre 2.

\section{ULBMP 3.0}
Ceci est le chapitre 3.

\section{ULBMP 4.0}
Ceci est le chapitre 4.

\section{Conclusion}
Ceci est une conclusion.

\end{document}
